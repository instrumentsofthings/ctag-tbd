#include "ctagSoundProcessorMoogFilt.hpp"
#include <iostream>
#include "helpers/ctagFastMath.hpp"

using namespace CTAG::SP;

ctagSoundProcessorMoogFilt::ctagSoundProcessorMoogFilt()
{
	setIsStereo();
	model = std::make_unique<ctagSPDataModel>(id, isStereo);
	model->LoadPreset(0);

	memset(V, 0, sizeof(V));
	memset(dV, 0, sizeof(dV));
	memset(tV, 0, sizeof(tV));
}

void ctagSoundProcessorMoogFilt::Process(const ProcessData &data)
{
	double dV0, dV1, dV2, dV3;

	// cutoff frequency (Hz)
	// TODO: currently max. frequency parameter seems to be around 4096 => internal scaling?
	float fCutoff = static_cast<float>(cutoff); 

	// range between [0, 4]
	float fResonance = static_cast<float>(resonance) / 4095.f * 4.f; 

	// currently allowing max. gain of factor 2
	float fDrive = static_cast<float>(drive) / 4095.f * 2.f;

/*
	// TODO: simulator does not repeat input audio file if parameter is polled here. seg fault?
	if (cv_cutoff != -1)
	{
		fCutoff = data.cv[cv_cutoff] * 4095.f; // in Hz
	}
	if (cv_resonance != -1)
	{
		fResonance = data.cv[cv_resonance] * 4.f;
	}
	if (cv_drive != -1)
	{
		fDrive = data.cv[cv_drive] * 2.f;
	}
*/

	// process cutoff frequency
	x = (MOOG_PI * fCutoff) / SAMPLE_RATE;
	g = 4.0 * MOOG_PI * VT * fCutoff * (1.0 - x) / (1.0 + x);

	for (int i = 0; i < this->bufSz; i++)
	{
		data.buf[i * 2 + this->processCh] = data.buf[i * 2 + this->processCh];

		dV0 = -g * (CTAG::SP::HELPERS::fasttanh((fDrive * data.buf[i * 2 + this->processCh] + fResonance * V[3]) / (2.0 * VT)) + tV[0]);
		V[0] += (dV0 + dV[0]) / (2.0 * SAMPLE_RATE);
		dV[0] = dV0;
		tV[0] = CTAG::SP::HELPERS::fasttanh(V[0] / (2.0 * VT));

		dV1 = g * (tV[0] - tV[1]);
		V[1] += (dV1 + dV[1]) / (2.0 * SAMPLE_RATE);
		dV[1] = dV1;
		tV[1] = CTAG::SP::HELPERS::fasttanh(V[1] / (2.0 * VT));

		dV2 = g * (tV[1] - tV[2]);
		V[2] += (dV2 + dV[2]) / (2.0 * SAMPLE_RATE);
		dV[2] = dV2;
		tV[2] = CTAG::SP::HELPERS::fasttanh(V[2] / (2.0 * VT));

		dV3 = g * (tV[2] - tV[3]);
		V[3] += (dV3 + dV[3]) / (2.0 * SAMPLE_RATE);
		dV[3] = dV3;
		tV[3] = CTAG::SP::HELPERS::fasttanh(V[3] / (2.0 * VT));

		data.buf[i * 2 + this->processCh] = V[3];
	}
}

ctagSoundProcessorMoogFilt::~ctagSoundProcessorMoogFilt()
{
}

const char *ctagSoundProcessorMoogFilt::GetCStrID() const
{
	return id.c_str();
}

void ctagSoundProcessorMoogFilt::setParamValueInternal(const string &id, const string &key, const int val)
{
	// autogenerated code here
	// sectionCpp0
if(id.compare("cutoff") == 0){
	if(key.compare("current") == 0){
		cutoff = val;
		return;
	}else if(key.compare("cv") == 0){
		if(val >= -1 && val <= 3)
			cv_cutoff = val;
	}
	return;
}
if(id.compare("resonance") == 0){
	if(key.compare("current") == 0){
		resonance = val;
		return;
	}else if(key.compare("cv") == 0){
		if(val >= -1 && val <= 3)
			cv_resonance = val;
	}
	return;
}
if(id.compare("drive") == 0){
	if(key.compare("current") == 0){
		drive = val;
		return;
	}else if(key.compare("cv") == 0){
		if(val >= -1 && val <= 3)
			cv_drive = val;
	}
	return;
}
// sectionCpp0



}

void ctagSoundProcessorMoogFilt::loadPresetInternal()
{
	// autogenerated code here
	// sectionCpp1
cutoff = model->GetParamValue("cutoff", "current");
cv_cutoff = model->GetParamValue("cutoff", "cv");
resonance = model->GetParamValue("resonance", "current");
cv_resonance = model->GetParamValue("resonance", "cv");
drive = model->GetParamValue("drive", "current");
cv_drive = model->GetParamValue("drive", "cv");
// sectionCpp1



}
